---
name: code-simplifier
description: |
  AI-powered code simplifier and cleanup expert. Transforms messy, over-engineered,
  or AI-generated "vibe coding" into clean, maintainable, production-ready code.
  
  Specializes in:
  - Removing unnecessary complexity and over-engineering
  - Consolidating redundant code and patterns
  - Improving readability and maintainability
  - Simplifying control flow and logic
  - Reducing nesting and cognitive load
  - Converting verbose code to idiomatic patterns
  - Preserving functionality while improving elegance
  
  Use when: code feels too complex, has too many layers of abstraction, contains
  duplicate logic, or was generated by AI without proper refinement.
  
  Triggers: simplify code, cleanup, refactor, reduce complexity, vibe coding cleanup,
  over-engineered, consolidate, readability, remove duplication
---

# Code Simplifier

üßπ Transform complex, messy code into clean, elegant solutions.

## üéØ Philosophy

> "Perfection is achieved not when there is nothing more to add, 
> but when there is nothing left to take away." ‚Äî Antoine de Saint-Exup√©ry

**Code simplification principles:**
1. **Clarity over cleverness**: Code should be obvious to readers
2. **Less is more**: Fewer lines often means less bugs
3. **Remove indirection**: Direct is better than indirect
4. **Kill duplication**: One source of truth
5. **Simplify conditionals**: Flatten nested logic
6. **Prefer standard library**: Don't reinvent the wheel

## üîç Common Issues to Fix

### 1. Over-Engineering

‚ùå **Before** (Over-engineered):
```python
class AbstractDataProcessor:
    def process(self, data):
        raise NotImplementedError

class ConcreteDataProcessor(AbstractDataProcessor):
    def process(self, data):
        return [x.strip() for x in data if x]

processor = ConcreteDataProcessor()
result = processor.process(raw_data)
```

‚úÖ **After** (Simple):
```python
result = [x.strip() for x in raw_data if x]
```

### 2. Deep Nesting

‚ùå **Before** (Nested):
```python
def get_user_email(user_id):
    if user_id:
        user = db.get_user(user_id)
        if user:
            if user.is_active:
                if user.email:
                    return user.email
    return None
```

‚úÖ **After** (Flat):
```python
def get_user_email(user_id: int | None) -> str | None:
    if not user_id:
        return None
    
    user = db.get_user(user_id)
    if not user or not user.is_active:
        return None
    
    return user.email
```

### 3. Redundant Abstractions

‚ùå **Before** (Too many layers):
```python
class UserManager:
    def __init__(self):
        self.repo = UserRepository()
        self.service = UserService(self.repo)
    
    def get_user(self, id):
        return self.service.get_user(id)

class UserService:
    def __init__(self, repo):
        self.repo = repo
    
    def get_user(self, id):
        return self.repo.get_by_id(id)

class UserRepository:
    def get_by_id(self, id):
        return db.query(User).filter_by(id=id).first()

# Usage
manager = UserManager()
user = manager.get_user(1)
```

‚úÖ **After** (Direct):
```python
def get_user(user_id: int) -> User | None:
    return db.query(User).filter_by(id=user_id).first()

# Usage
user = get_user(1)
```

### 4. Verbose Conditionals

‚ùå **Before**:
```python
if condition == True:
    result = True
else:
    result = False
```

‚úÖ **After**:
```python
result = condition
```

### 5. Unnecessary List Operations

‚ùå **Before**:
```python
result = []
for item in items:
    if item.is_valid():
        processed = item.process()
        result.append(processed)
return result
```

‚úÖ **After**:
```python
return [item.process() for item in items if item.is_valid()]
```

## üõ†Ô∏è Simplification Patterns

### Pattern 1: Early Returns

Replace nested conditionals with early returns:

```python
def process_data(data):
    if not data:
        return None
    if not data.get('items'):
        return []
    
    return [process(item) for item in data['items']]
```

### Pattern 2: Guard Clauses

```python
def calculate_discount(order):
    if not order:
        return 0
    if order.total <= 0:
        return 0
    if not order.customer:
        return 0
    
    # Main logic here
    return order.total * 0.1
```

### Pattern 3: Extract Helper Functions

```python
def process_orders(orders):
    return [
        format_order(order)
        for order in orders
        if is_valid_order(order)
    ]

def is_valid_order(order):
    return order and order.status == 'confirmed'

def format_order(order):
    return {
        'id': order.id,
        'total': order.total,
    }
```

### Pattern 4: Use Built-ins

```python
# Instead of custom loops
result = list(filter(lambda x: x > 0, numbers))

# Use built-in
result = [x for x in numbers if x > 0]

# Or
result = max(items, key=lambda x: x.value, default=None)
```

### Pattern 5: Dataclasses Over Classes

```python
# Instead of verbose __init__
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

# Use dataclass
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: float
    y: float
```

## üìã Simplification Checklist

When reviewing code, check for:

- [ ] **Unnecessary classes**: Can this be a function?
- [ ] **Deep nesting**: Can we use early returns?
- [ ] **Redundant comments**: Is the code self-explanatory?
- [ ] **Over-abstraction**: Do we need this interface?
- [ ] **Verbose syntax**: Can we use built-ins?
- [ ] **Duplicate logic**: Can we extract a helper?
- [ ] **Mutable state**: Can we use immutable data?
- [ ] **Complex conditionals**: Can we simplify the logic?

## üéØ Before/After Examples

### Example 1: Configuration Loading

‚ùå **Before** (66 lines):
```python
class ConfigLoader:
    def __init__(self, config_path):
        self.config_path = config_path
        self.config = None
    
    def load(self):
        if not self.config_path:
            raise ValueError("No config path")
        
        if not os.path.exists(self.config_path):
            raise FileNotFoundError(self.config_path)
        
        with open(self.config_path) as f:
            content = f.read()
        
        if not content:
            raise ValueError("Empty config")
        
        try:
            self.config = json.loads(content)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON: {e}")
        
        return self.config
    
    def get(self, key, default=None):
        if self.config is None:
            self.load()
        return self.config.get(key, default)
```

‚úÖ **After** (9 lines):
```python
def load_config(path: str) -> dict:
    with open(path) as f:
        return json.load(f)

# Usage
config = load_config("config.json")
host = config.get("host", "localhost")
```

### Example 2: Data Validation

‚ùå **Before**:
```python
def validate_user(data):
    errors = []
    
    if 'name' not in data:
        errors.append("Missing name")
    else:
        if not data['name']:
            errors.append("Empty name")
        else:
            if len(data['name']) < 2:
                errors.append("Name too short")
    
    if 'email' not in data:
        errors.append("Missing email")
    else:
        if not re.match(r'[^@]+@[^@]+', data['email']):
            errors.append("Invalid email")
    
    return errors
```

‚úÖ **After**:
```python
from pydantic import BaseModel, EmailStr, Field

class User(BaseModel):
    name: str = Field(min_length=2)
    email: EmailStr

# Usage
try:
    user = User(**data)
except ValidationError as e:
    errors = e.errors()
```

## üîß Scripts

| Script | Purpose |
|--------|---------|
| `scripts/simplify_file.py` | Simplify a single file |
| `scripts/analyze_complexity.py` | Find overly complex code |
| `scripts/remove_duplicates.py` | Consolidate duplicate code |

## üìù Workflow

1. **Analyze**: Identify complexity smells
2. **Preserve**: Ensure tests pass before changes
3. **Simplify**: Apply simplification patterns
4. **Verify**: Confirm behavior is unchanged
5. **Iterate**: Repeat until code is clean

## üôè Acknowledgments

This skill draws inspiration from:
- [Anthropic Code Simplifier Plugin](https://github.com/anthropics/claude-plugins-official/tree/main/plugins/code-simplifier) - For the core philosophy of reducing complexity and removing unnecessary abstraction
- [Refactoring](https://refactoring.com/) by Martin Fowler - For systematic code improvement patterns
- [Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/) by Rich Hickey - For distinguishing simple vs. easy
- [A Philosophy of Software Design](https://web.stanford.edu/~ouster/cgi-bin/book.php) by John Ousterhout - For managing complexity in software design

---

*Simple is the ultimate sophistication.*
